# 03 - Development & Legislative Workflow

This document outlines the standard operating procedure for creating, validating, and enacting any policy change within the system.

## The Two-Stage Legislative Process

All policies mature through two distinct stages:

1.  **Bill Stage:** A draft proposal. Bills are not active and are used for development, debate, and validation. They reside in the `parliament_policies/bills/` directory.
2.  **Act Stage:** A Bill that has been validated and approved. Acts are the official, enforceable laws of the system, executed by the Executive branch. The promotion from Bill to Act is a formal step, typically a merge into a protected `main` branch.

## The Hybrid Policy Model

We use a hybrid model to manage system policies, providing both safety and flexibility.

1.  **Tier 1: Foundational Policies (Managed as Code):**
    *   **What:** Core, high-impact business rules with complex interactions (e.g., rent calculation logic). Managed as structured YAML files.
    *   **Change Process:** Requires a formal developer workflow (Pull Request, validation, merge).

2.  **Tier 2: Operational Parameters (Managed via GUI):**
    *   **What:** Simple, low-risk variables (e.g., the value of a late fee). Managed via a secure Admin Portal GUI.
    *   **Safety:** The GUI's editable fields and their validation rules are defined in the Tier 1 policy files.

## The `bludeprint validation tool`

This is an automated safety net that runs on every proposed "Bill". It performs two critical types of analysis:

### 1. Event-Based Impact Analysis (The Graph Model)

Instead of viewing processes as simple linear trees, the system is modeled as a graph of interconnected logical nodes (a "mind map").

*   **How it works:** When a policy change is proposed, the tool identifies the core **Event** (e.g., `DepositReturned`) and traverses the entire system graph to find every single component, agent, and data store that is affected by that event.
*   **Benefit:** This provides a true, system-wide impact analysis, preventing unintended side effects.

### 2. Data & Policy Versioning

To ensure historical data integrity, the system adheres to the principle that **logic evolves, but history is immutable**.

*   **Policy Versioning:** Foundational policies are versioned (e.g., `rent_logic_v1`, `rent_logic_v2`).
*   **Data Tagging:** All data generated by a policy is "stamped" with the version of the policy that created it.
*   **Validation:** The `bludeprint` tool ensures that any change that alters data structure is properly versioned and that the relevant AI agents are updated to handle both old and new data formats.

## Configuration Loading Strategy

To prevent conflicts between the two policy tiers, the system loads configuration in layers:

1.  **Defaults from File:** The application first loads the default values from the policy files in the code.
2.  **Overrides from Database:** It then loads the current values set by the GUI from a configuration database.
3.  **Merge:** The database values always overwrite the file defaults, ensuring GUI changes are preserved across deployments.

## Automated Deployment (CI/CD)

Any code or policy change that is successfully validated and merged into the `main` branch of a component will automatically trigger a deployment pipeline.